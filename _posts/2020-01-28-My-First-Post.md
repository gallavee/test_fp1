---
keywords: fastai
description: A tutorial of fastpages for Jupyter notebooks.
title: My Test Blog Post
toc: true 
badges: true
comments: true
categories: [jupyter]
image: images/chart-preview.pn
nb_path: 2020-01-28-My-First-Post.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 2020-01-28-My-First-Post.ipynb
-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">nbdev</span> <span class="k">import</span> <span class="n">export2html</span>
<span class="kn">from</span> <span class="nn">nbdev.export2html</span> <span class="k">import</span> <span class="n">Config</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">_re_digits</span><span class="p">,</span> <span class="n">_to_html</span><span class="p">,</span> <span class="n">_re_block_notes</span>
<span class="c1"># from fast_template import rename_for_jekyll</span>

<span class="n">warnings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
<span class="c1"># Modify the naming process such that destination files get named properly for Jekyll _posts</span>
<span class="k">def</span> <span class="nf">_nb2htmlfname</span><span class="p">(</span><span class="n">nb_path</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
    <span class="n">fname</span> <span class="o">=</span> <span class="n">rename_for_jekyll</span><span class="p">(</span><span class="n">nb_path</span><span class="p">,</span> <span class="n">warnings</span><span class="o">=</span><span class="n">warnings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">Config</span><span class="p">()</span><span class="o">.</span><span class="n">doc_path</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="o">/</span><span class="n">fname</span>

<span class="c1"># TODO: Open a GitHub Issue in addition to printing warnings</span>
<span class="k">for</span> <span class="n">original</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">warnings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{original}</span><span class="s1"> has been renamed to </span><span class="si">{new}</span><span class="s1"> to be complaint with Jekyll naming conventions.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
<span class="c1">## apply monkey patches</span>
<span class="n">export2html</span><span class="o">.</span><span class="n">_nb2htmlfname</span> <span class="o">=</span> <span class="n">_nb2htmlfname</span>
<span class="n">export2html</span><span class="o">.</span><span class="n">notebook2html</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="s1">&#39;/Users/glavee/repos/test_fp1/_notebooks/*.ipynb&#39;</span><span class="p">,</span>
                          <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;/Users/glavee/repos/test_fp1/_posts/&#39;</span><span class="p">,</span> 
                          <span class="n">template_file</span><span class="o">=</span><span class="s1">&#39;/Users/glavee/repos/test_fp1/_action_files/fastpages.tpl&#39;</span><span class="p">,)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>converting: /Users/glavee/repos/test_fp1/_notebooks/2020-02-20-test.ipynb
Use `create_config` to create settings.ini for the first time
converting: /Users/glavee/repos/test_fp1/_notebooks/2020-01-28-My-First-Post.ipynb
Use `create_config` to create settings.ini for the first time
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">Exception</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-24-3e054971f67d&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-intense-fg ansi-bold">     21</span> export2html.notebook2html(fname=&#39;/Users/glavee/repos/test_fp1/_notebooks/*.ipynb&#39;,
<span class="ansi-green-intense-fg ansi-bold">     22</span>                           dest<span class="ansi-blue-fg">=</span><span class="ansi-blue-fg">&#39;/Users/glavee/repos/test_fp1/_posts/&#39;</span><span class="ansi-blue-fg">,</span>
<span class="ansi-green-fg">---&gt; 23</span><span class="ansi-red-fg">                           template_file=&#39;/Users/glavee/repos/test_fp1/_action_files/fastpages.tpl&#39;,)
</span>
<span class="ansi-green-fg">~/anaconda3/envs/p37/lib/python3.7/site-packages/nbdev/export2html.py</span> in <span class="ansi-cyan-fg">notebook2html</span><span class="ansi-blue-fg">(fname, force_all, n_workers, cls, template_file, exporter, dest)</span>
<span class="ansi-green-intense-fg ansi-bold">    486</span>         <span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> all<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    487</span>             msg <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">&#34;Conversion failed on the following:\n&#34;</span>
<span class="ansi-green-fg">--&gt; 488</span><span class="ansi-red-fg">             </span><span class="ansi-green-fg">raise</span> Exception<span class="ansi-blue-fg">(</span>msg <span class="ansi-blue-fg">+</span> <span class="ansi-blue-fg">&#39;\n&#39;</span><span class="ansi-blue-fg">.</span>join<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">[</span>f<span class="ansi-blue-fg">.</span>name <span class="ansi-green-fg">for</span> p<span class="ansi-blue-fg">,</span>f <span class="ansi-green-fg">in</span> zip<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">,</span>files<span class="ansi-blue-fg">)</span> <span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> p<span class="ansi-blue-fg">]</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    489</span> 
<span class="ansi-green-intense-fg ansi-bold">    490</span> <span class="ansi-red-fg"># Cell</span>

<span class="ansi-red-fg">Exception</span>: Conversion failed on the following:
2020-01-28-My-First-Post.ipynb
2020-02-20-test.ipynb</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">nbdev.imports</span> <span class="k">import</span> <span class="n">create_config</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span><span class="nb">cd</span> ../_action_files/
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>cat /Users/glavee/anaconda3/envs/p37/lib/python3.7/site-packages/nbdev/export2html.py
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre># AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_export2html.ipynb (unless otherwise specified).

__all__ = [&#39;HTMLParseAttrs&#39;, &#39;remove_widget_state&#39;, &#39;hide_cells&#39;, &#39;clean_exports&#39;, &#39;treat_backticks&#39;,
           &#39;add_jekyll_notes&#39;, &#39;copy_images&#39;, &#39;adapt_img_path&#39;, &#39;escape_latex&#39;, &#39;collapse_cells&#39;, &#39;remove_hidden&#39;,
           &#39;find_default_level&#39;, &#39;add_show_docs&#39;, &#39;remove_fake_headers&#39;, &#39;remove_empty&#39;, &#39;get_metadata&#39;,
           &#39;ExecuteShowDocPreprocessor&#39;, &#39;execute_nb&#39;, &#39;cite2link&#39;, &#39;write_tmpl&#39;, &#39;write_tmpls&#39;, &#39;nbdev_exporter&#39;,
           &#39;process_cells&#39;, &#39;process_cell&#39;, &#39;convert_nb&#39;, &#39;notebook2html&#39;, &#39;convert_md&#39;, &#39;nb_detach_cells&#39;,
           &#39;create_default_sidebar&#39;, &#39;make_sidebar&#39;]

# Cell
from .imports import *
from .sync import *
from .export import *
from .showdoc import *
from .template import *

from html.parser import HTMLParser
from nbconvert.preprocessors import ExecutePreprocessor, Preprocessor
from nbconvert import HTMLExporter,MarkdownExporter
import traitlets

# Cell
class HTMLParseAttrs(HTMLParser):
    &#34;Simple HTML parser which stores any attributes in `attrs` dict&#34;
    def handle_starttag(self, tag, attrs): self.tag,self.attrs = tag,dict(attrs)

    def attrs2str(self):
        &#34;Attrs as string&#34;
        return &#39; &#39;.join([f&#39;{k}=&#34;{v}&#34;&#39; for k,v in self.attrs.items()])

    def show(self):
        &#34;Tag with updated attrs&#34;
        return f&#39;&lt;{self.tag} {self.attrs2str()} /&gt;&#39;

    def __call__(self, s):
        &#34;Parse `s` and store attrs&#34;
        self.feed(s)
        return self.attrs

# Cell
def remove_widget_state(cell):
    &#34;Remove widgets in the output of `cells`&#34;
    if cell[&#39;cell_type&#39;] == &#39;code&#39; and &#39;outputs&#39; in cell:
        cell[&#39;outputs&#39;] = [l for l in cell[&#39;outputs&#39;]
                           if not (&#39;data&#39; in l and &#39;application/vnd.jupyter.widget-view+json&#39; in l.data)]
    return cell

# Cell
# Matches any cell that has a `show_doc` or an `#export` in it
_re_cell_to_hide = r&#39;s*show_doc\(|^\s*#\s*export\s+|^\s*#\s*hide_input\s+&#39;

# Matches any cell with `#hide_output` or `#hide_output`
_re_hide_output = r&#39;^\s*#\s*hide-output\s+|^\s*#\s*hide_output\s+&#39;

# Cell
def hide_cells(cell):
    &#34;Hide inputs of `cell` that need to be hidden&#34;
    if check_re(cell, _re_cell_to_hide):  cell[&#39;metadata&#39;] = {&#39;hide_input&#39;: True}
    elif check_re(cell, _re_hide_output):  cell[&#39;metadata&#39;] = {&#39;hide_output&#39;: True}
    return cell

# Cell
# Matches any line containing an #exports
_re_exports = re.compile(r&#39;^#\s*exports[^\n]*\n&#39;)

# Cell
def clean_exports(cell):
    &#34;Remove exports flag from `cell`&#34;
    cell[&#39;source&#39;] = _re_exports.sub(&#39;&#39;, cell[&#39;source&#39;])
    return cell

# Cell
def treat_backticks(cell):
    &#34;Add links to backticks words in `cell`&#34;
    if cell[&#39;cell_type&#39;] == &#39;markdown&#39;: cell[&#39;source&#39;] = add_doc_links(cell[&#39;source&#39;])
    return cell

# Cell
_re_nb_link = re.compile(r&#34;&#34;&#34;
# Catches any link to a local notebook and keeps the title in group 1, the link without .ipynb in group 2
\[          # Opening [
([^\]]*)    # Catching group for any character except ]
\]\(        # Closing ], opening (
([^http]    # Catching group that must not begin by html (local notebook)
[^\)]*)     # and containing anything but )
.ipynb\)    # .ipynb and closing )
&#34;&#34;&#34;, re.VERBOSE)

# Cell
_re_block_notes = re.compile(r&#34;&#34;&#34;
# Catches any pattern &gt; Title: content with title in group 1 and content in group 2
^\s*&gt;\s*     # &gt; followed by any number of whitespace
([^:]*)      # Catching group for any character but :
:\s*         # : then any number of whitespace
([^\n]*)     # Catching group for anything but a new line character
(?:\n|$)     # Non-catching group for either a new line or the end of the text
&#34;&#34;&#34;, re.VERBOSE | re.MULTILINE)

# Cell
def _to_html(text):
    return text.replace(&#34;&#39;&#34;, &#34;&amp;#8217;&#34;)

# Cell
def add_jekyll_notes(cell):
    &#34;Convert block quotes to jekyll notes in `cell`&#34;
    styles = Config().get(&#39;jekyll_styles&#39;, &#39;note,warning,tip,important&#39;).split(&#39;,&#39;)
    def _inner(m):
        title,text = m.groups()
        if title.lower() not in styles: return f&#34;&gt; {title}:{text}&#34;
        return &#39;{% include &#39;+title.lower()+&#34;.html content=\&#39;&#34;+_to_html(text)+&#34;\&#39; %}&#34;
    if cell[&#39;cell_type&#39;] == &#39;markdown&#39;:
        cell[&#39;source&#39;] = _re_block_notes.sub(_inner, cell[&#39;source&#39;])
    return cell

# Cell
_re_image = re.compile(r&#34;&#34;&#34;
# Catches any image file used, either with `![alt](image_file)` or `&lt;img src=&#34;image_file&#34;&gt;`
^(!\[           #   Beginning of line (since re.MULTILINE is passed) followed by ![ in a catching group
[^\]]*          #   Anything but ]
\]\()           #   Closing ] and opening (, end of the first catching group
([^\)]*)        #   Catching block with any character but )
(\))            #   Catching group with closing )
|               # OR
^(&lt;img\ [^&gt;]*&gt;)  #   Catching group with &lt;img some_html_code&gt;
&#34;&#34;&#34;, re.MULTILINE | re.VERBOSE)

_re_image1 = re.compile(r&#34;^&lt;img\ [^&gt;]*&gt;&#34;, re.MULTILINE)

# Cell
def _img2jkl(d, h, jekyll=True):
    if not jekyll: return &#39;&lt;img &#39; + h.attrs2str() + &#39;&gt;&#39;
    if &#39;width&#39; in d: d[&#39;max-width&#39;] = d.pop(&#39;width&#39;)
    if &#39;src&#39; in d:   d[&#39;file&#39;] = d.pop(&#39;src&#39;)
    return &#39;{% include image.html &#39; + h.attrs2str() + &#39; %}&#39;

# Cell
def _is_real_image(src):
    return not (src.startswith(&#39;http://&#39;) or src.startswith(&#39;https://&#39;) or src.startswith(&#39;data:image/&#39;))

# Cell
def copy_images(cell, fname, dest, jekyll=True):
    &#34;Copy images referenced in `cell` from `fname` parent folder to `dest` folder&#34;
    def _rep_src(m):
        grps = m.groups()
        if grps[3] is not None:
            h = HTMLParseAttrs()
            dic = h(grps[3])
            src = dic[&#39;src&#39;]
        else:
            cap = re.search(r&#39;(\s&#34;[^&#34;]*&#34;)&#39;, grps[1])
            if cap is not None:
                grps = (grps[0], re.sub(r&#39;\s&#34;[^&#34;]*&#34;&#39;, &#39;&#39;, grps[1]), cap.groups()[0] + grps[2], grps[3])
            src = grps[1]
        if _is_real_image(src):
            os.makedirs((Path(dest)/src).parent, exist_ok=True)
            shutil.copy(Path(fname).parent/src, Path(dest)/src)
            src = Config().doc_baseurl + src
        if grps[3] is not None:
            dic[&#39;src&#39;] = src
            return _img2jkl(dic, h, jekyll=jekyll)
        else:  return f&#34;{grps[0]}{src}{grps[2]}&#34;
    if cell[&#39;cell_type&#39;] == &#39;markdown&#39;: cell[&#39;source&#39;] = _re_image.sub(_rep_src, cell[&#39;source&#39;])
    return cell

# Cell
def _relative_to(path1, path2):
    p1,p2 = Path(path1).absolute().parts,Path(path2).absolute().parts
    i=0
    while i &lt;len(p1) and i&lt;len(p2) and p1[i] == p2[i]: i+=1
    p1,p2 = p1[i:],p2[i:]
    return os.path.sep.join([&#39;..&#39; for _ in p2] + list(p1))

# Cell
def adapt_img_path(cell, fname, dest, jekyll=True):
    &#34;Adapt path of images referenced in `cell` from `fname` to work in folder `dest`&#34;
    def _rep(m):
        gps = m.groups()
        if gps[0] is not None:
            start,img,end = gps[:3]
            if not (img.startswith(&#39;http:/&#39;) or img.startswith(&#39;https:/&#39;)):
                img = _relative_to(fname.parent/img, dest)
            return f&#39;{start}{img}{end}&#39;
        else:
            h = HTMLParseAttrs()
            dic = h(gps[3])
            if not (dic[&#39;src&#39;].startswith(&#39;http:/&#39;) or dic[&#39;src&#39;].startswith(&#39;https:/&#39;)):
                dic[&#39;src&#39;] = _relative_to(fname.parent/dic[&#39;src&#39;], dest)
            return _img2jkl(dic, h, jekyll=jekyll)
    if cell[&#39;cell_type&#39;] == &#39;markdown&#39;: cell[&#39;source&#39;] = _re_image.sub(_rep, cell[&#39;source&#39;])
    return cell

# Cell
_re_latex = re.compile(r&#39;^(\$\$.*\$\$)$&#39;, re.MULTILINE)

# Cell
def escape_latex(cell):
    if cell[&#39;cell_type&#39;] != &#39;markdown&#39;: return cell
    cell[&#39;source&#39;] = _re_latex.sub(r&#39;{% raw %}\n\1\n{% endraw %}&#39;, cell[&#39;source&#39;])
    return cell

# Cell
#Matches any cell with #collapse or #collapse_hide
_re_cell_to_collapse_closed = re.compile(r&#39;^\s*#\s*(collapse|collapse_hide|collapse-hide)\s+&#39;)

#Matches any cell with #collapse_show
_re_cell_to_collapse_open = re.compile(r&#39;^\s*#\s*(collapse_show|collapse-show)\s+&#39;)

#Matches any cell with #collapse_output or #collapse-output
_re_cell_to_collapse_output = re.compile(r&#39;^\s*#\s*(collapse_output|collapse-output)\s+&#39;)

# Cell
def collapse_cells(cell):
    &#34;Add a collapse button to inputs of `cell` in either the open or closed position&#34;
    if check_re(cell, _re_cell_to_collapse_closed):  cell[&#39;metadata&#39;] = {&#39;collapse_hide&#39;: True}
    elif check_re(cell, _re_cell_to_collapse_open):  cell[&#39;metadata&#39;] = {&#39;collapse_show&#39;: True}
    elif check_re(cell, _re_cell_to_collapse_output):  cell[&#39;metadata&#39;] = {&#39;collapse_output&#39;: True}
    return cell

# Cell
#Matches any cell with #hide or #default_exp or #default_cls_lvl or #exporti
_re_cell_to_remove = re.compile(r&#39;^\s*#\s*(hide\s|default_exp|default_cls_lvl|exporti|all_([^\s]*))\s*&#39;)

# Cell
def remove_hidden(cells):
    &#34;Remove in `cells` the ones with a flag `#hide`, `#default_exp` or `#default_cls_lvl` or `#exporti`&#34;
    return [c for c in cells if _re_cell_to_remove.search(c[&#39;source&#39;]) is None]

# Cell
_re_default_cls_lvl = re.compile(r&#34;&#34;&#34;
^               # Beginning of line (since re.MULTILINE is passed)
\s*\#\s*        # Any number of whitespace, #, any number of whitespace
default_cls_lvl # default_cls_lvl
\s*             # Any number of whitespace
(\d*)           # Catching group for any number of digits
\s*$            # Any number of whitespace and end of line (since re.MULTILINE is passed)
&#34;&#34;&#34;, re.IGNORECASE | re.MULTILINE | re.VERBOSE)

# Cell
def find_default_level(cells):
    &#34;Find in `cells` the default class level.&#34;
    for cell in cells:
        tst = check_re(cell, _re_default_cls_lvl)
        if tst: return int(tst.groups()[0])
    return 2

# Cell
#Find a cell with #export(s)
_re_export = re.compile(r&#39;^\s*#\s*exports?\s*&#39;, re.IGNORECASE | re.MULTILINE)
_re_show_doc = re.compile(r&#34;&#34;&#34;
# First one catches any cell with a #export or #exports, second one catches any show_doc and get the first argument in group 1
show_doc     # show_doc
\s*\(\s*     # Any number of whitespace, opening (, any number of whitespace
([^,\)\s]*)  # Catching group for any character but a comma, a closing ) or a whitespace
[,\)\s]      # A comma, a closing ) or a whitespace
&#34;&#34;&#34;, re.MULTILINE | re.VERBOSE)

# Cell
def _show_doc_cell(name, cls_lvl=None):
    return {&#39;cell_type&#39;: &#39;code&#39;,
            &#39;execution_count&#39;: None,
            &#39;metadata&#39;: {},
            &#39;outputs&#39;: [],
            &#39;source&#39;: f&#34;show_doc({name}{&#39;&#39; if cls_lvl is None else f&#39;, default_cls_level={cls_lvl}&#39;})&#34;}

def add_show_docs(cells, cls_lvl=None):
    &#34;Add `show_doc` for each exported function or class&#34;
    documented = [_re_show_doc.search(cell[&#39;source&#39;]).groups()[0] for cell in cells
                  if cell[&#39;cell_type&#39;]==&#39;code&#39; and _re_show_doc.search(cell[&#39;source&#39;]) is not None]
    res = []
    for cell in cells:
        res.append(cell)
        if check_re(cell, _re_export):
            names = export_names(cell[&#39;source&#39;], func_only=True)
            for n in names:
                if n not in documented: res.append(_show_doc_cell(n, cls_lvl=cls_lvl))
    return res


_re_fake_header = re.compile(r&#34;&#34;&#34;
# Matches any fake header (one that ends with -)
\#+    # One or more #
\s+    # One or more of whitespace
.*     # Any char
-\s*   # A dash followed by any number of white space
$      # End of text
&#34;&#34;&#34;, re.VERBOSE)

# Cell
def remove_fake_headers(cells):
    &#34;Remove in `cells` the fake header&#34;
    return [c for c in cells if c[&#39;cell_type&#39;]==&#39;code&#39; or _re_fake_header.search(c[&#39;source&#39;]) is None]

# Cell
def remove_empty(cells):
    &#34;Remove in `cells` the empty cells&#34;
    return [c for c in cells if len(c[&#39;source&#39;]) &gt;0]

# Cell
_re_title_summary = re.compile(r&#34;&#34;&#34;
# Catches the title and summary of the notebook, presented as # Title &gt; summary, with title in group 1 and summary in group 2
^\s*       # Beginning of text followe by any number of whitespace
\#\s+      # # followed by one or more of whitespace
([^\n]*)   # Catching group for any character except a new line
\n+        # One or more new lines
&gt;[ ]*       # &gt; followed by any number of whitespace
([^\n]*)   # Catching group for any character except a new line
&#34;&#34;&#34;, re.VERBOSE)

_re_properties = re.compile(r&#34;&#34;&#34;
^-\s+      # Beginnig of a line followed by - and at least one space
(.*?)      # Any pattern (shortest possible)
\s*:\s*    # Any number of whitespace, :, any number of whitespace
(.*?)$     # Any pattern (shortest possible) then end of line
&#34;&#34;&#34;, re.MULTILINE | re.VERBOSE)

# Cell
def get_metadata(cells):
    &#34;Find the cell with title and summary in `cells`.&#34;
    for i,cell in enumerate(cells):
        if cell[&#39;cell_type&#39;] == &#39;markdown&#39;:
            match = _re_title_summary.match(cell[&#39;source&#39;])
            if match:
                cells.pop(i)
                attrs = {k:v for k,v in _re_properties.findall(cell[&#39;source&#39;])}
                return {&#39;keywords&#39;: &#39;fastai&#39;,
                        &#39;summary&#39; : match.groups()[1],
                        &#39;title&#39;   : match.groups()[0],
                        **attrs}

    return {&#39;keywords&#39;: &#39;fastai&#39;,
            &#39;summary&#39; : &#39;summary&#39;,
            &#39;title&#39;   : &#39;Title&#39;}

# Cell
_re_cell_to_execute = ReLibName(r&#34;^\s*show_doc\(([^\)]*)\)|^from LIB_NAME\.&#34;, re.MULTILINE)

# Cell
class ExecuteShowDocPreprocessor(ExecutePreprocessor):
    &#34;An `ExecutePreprocessor` that only executes `show_doc` and `import` cells&#34;
    def preprocess_cell(self, cell, resources, index):
        if &#39;source&#39; in cell and cell[&#39;cell_type&#39;] == &#34;code&#34;:
            if _re_cell_to_execute.re.search(cell[&#39;source&#39;]):
                return super().preprocess_cell(cell, resources, index)
        return cell, resources

# Cell
def _import_show_doc_cell(mod=None):
    &#34;Add an import show_doc cell.&#34;
    source = f&#34;#export\nfrom nbdev.showdoc import show_doc&#34;
    if mod:  source += f&#34;\nfrom {Config().lib_name}.{mod} import *&#34;
    return {&#39;cell_type&#39;: &#39;code&#39;,
            &#39;execution_count&#39;: None,
            &#39;metadata&#39;: {&#39;hide_input&#39;: True},
            &#39;outputs&#39;: [],
            &#39;source&#39;: source}

def execute_nb(nb, mod=None, metadata=None, show_doc_only=True):
    &#34;Execute `nb` (or only the `show_doc` cells) with `metadata`&#34;
    nb[&#39;cells&#39;].insert(0, _import_show_doc_cell(mod))
    ep_cls = ExecuteShowDocPreprocessor if show_doc_only else ExecutePreprocessor
    ep = ep_cls(timeout=600, kernel_name=&#39;python3&#39;)
    metadata = metadata or {}
    pnb = nbformat.from_dict(nb)
    ep.preprocess(pnb, metadata)
    return pnb

# Cell
_re_cite = re.compile(r&#34;(\\cite{)([^}]*)(})&#34;, re.MULTILINE | re.VERBOSE) # Catches citations used with `\cite{}`

# Cell
def _textcite2link(text):
    citations = _re_cite.finditer(text)
    out = []
    start_pos = 0
    for cit_group in citations:
        cit_pos_st =  cit_group.span()[0]
        cit_pos_fin =  cit_group.span()[1]
        out.append(text[start_pos:cit_pos_st])
        out.append(&#39;[&#39;)
        cit_group = cit_group[2].split(&#39;,&#39;)
        for i, cit in enumerate(cit_group):
            cit=cit.strip()
            out.append(f&#34;&#34;&#34;&lt;a class=&#34;latex_cit&#34; id=&#34;call-{cit}&#34; href=&#34;#cit-{cit}&#34;&gt;{cit}&lt;/a&gt;&#34;&#34;&#34;)
            if i != len(cit_group) - 1:
                out.append(&#39;,&#39;)
        out.append(&#39;]&#39;)
        start_pos = cit_pos_fin
    out.append(text[start_pos:])
    return &#39;&#39;.join(out)

# Cell
def cite2link(cell):
    &#39;&#39;&#39;Creates links from \cite{} to Refenrence section generated by jupyter_latex_envs&#39;&#39;&#39;
    if cell[&#39;cell_type&#39;] == &#39;markdown&#39;: cell[&#39;source&#39;] = _textcite2link(cell[&#39;source&#39;])
    return cell

# Cell
def write_tmpl(tmpl, nms, cfg, dest):
    &#34;Write `tmpl` to `dest` (if missing) filling in `nms` in template using dict `cfg`&#34;
    if dest.exists(): return
    vs = {o:cfg.d[o] for o in nms.split()}
    outp = tmpl.format(**vs)
    dest.write_text(outp)

# Cell
def write_tmpls():
    &#34;Write out _config.yml and _data/topnav.yml using templates&#34;
    cfg = Config()
    write_tmpl(config_tmpl, &#39;user lib_name title copyright description&#39;, cfg, cfg.doc_path/&#39;_config.yml&#39;)
    write_tmpl(topnav_tmpl, &#39;user lib_name&#39;, cfg, cfg.doc_path/&#39;_data&#39;/&#39;topnav.yml&#39;)
    write_tmpl(makefile_tmpl, &#39;nbs_path lib_name&#39;, cfg, cfg.config_file.parent/&#39;Makefile&#39;)

# Cell
def nbdev_exporter(cls=HTMLExporter, template_file=None):
    cfg = traitlets.config.Config()
    exporter = cls(cfg)
    exporter.exclude_input_prompt=True
    exporter.exclude_output_prompt=True
    exporter.anchor_link_text = &#39; &#39;
    exporter.template_file = &#39;jekyll.tpl&#39; if template_file is None else template_file
    exporter.template_path.append(str(Path(__file__).parent/&#39;templates&#39;))
    return exporter

# Cell
process_cells = [remove_fake_headers, remove_hidden, remove_empty]
process_cell  = [hide_cells, collapse_cells, remove_widget_state, add_jekyll_notes, escape_latex, cite2link]

# Cell
_re_digits = re.compile(r&#39;^\d+\S*?_&#39;)

# Cell
def _nb2htmlfname(nb_path, dest=None):
    if dest is None: dest = Config().doc_path
    return Path(dest)/_re_digits.sub(&#39;&#39;, nb_path.with_suffix(&#39;.html&#39;).name)

# Cell
def convert_nb(fname, cls=HTMLExporter, template_file=None, exporter=None, dest=None):
    &#34;Convert a notebook `fname` to html file in `dest_path`.&#34;
    fname = Path(fname).absolute()
    nb = read_nb(fname)
    meta_jekyll = get_metadata(nb[&#39;cells&#39;])
    meta_jekyll[&#39;nb_path&#39;] = str(fname.relative_to(Config().lib_path.parent))
    cls_lvl = find_default_level(nb[&#39;cells&#39;])
    mod = find_default_export(nb[&#39;cells&#39;])
    nb[&#39;cells&#39;] = compose(*process_cells,partial(add_show_docs, cls_lvl=cls_lvl))(nb[&#39;cells&#39;])
    _func = compose(partial(copy_images, fname=fname, dest=Config().doc_path), *process_cell, treat_backticks)
    nb[&#39;cells&#39;] = [_func(c) for c in nb[&#39;cells&#39;]]
    nb = execute_nb(nb, mod=mod)
    nb[&#39;cells&#39;] = [clean_exports(c) for c in nb[&#39;cells&#39;]]
    if exporter is None: exporter = nbdev_exporter(cls=cls, template_file=template_file)
    with open(_nb2htmlfname(fname, dest=dest),&#39;w&#39;) as f:
        f.write(exporter.from_notebook_node(nb, resources=meta_jekyll)[0])

# Cell
def _notebook2html(fname, cls=HTMLExporter, template_file=None, exporter=None, dest=None):
    time.sleep(random.random())
    print(f&#34;converting: {fname}&#34;)
    try:
        convert_nb(fname, cls=cls, template_file=template_file, exporter=exporter, dest=dest)
        return True
    except Exception as e:
        print(e)
        return False

# Cell
def notebook2html(fname=None, force_all=False, n_workers=None, cls=HTMLExporter, template_file=None, exporter=None, dest=None):
    &#34;Convert all notebooks matching `fname` to html files&#34;
    if fname is None:
        files = [f for f in Config().nbs_path.glob(&#39;*.ipynb&#39;) if not f.name.startswith(&#39;_&#39;)]
    else:
        p = Path(fname)
        files = list(p.parent.glob(p.name))
    if len(files)==1:
        force_all = True
        if n_workers is None: n_workers=0
    if not force_all:
        # only rebuild modified files
        files,_files = [],files.copy()
        for fname in _files:
            fname_out = _nb2htmlfname(Path(fname).absolute(), dest=dest)
            if not fname_out.exists() or os.path.getmtime(fname) &gt;= os.path.getmtime(fname_out):
                files.append(fname)
    if len(files)==0: print(&#34;No notebooks were modified&#34;)
    else:
        passed = parallel(_notebook2html, files, n_workers=n_workers, cls=cls, template_file=template_file, exporter=exporter, dest=dest)
        if not all(passed):
            msg = &#34;Conversion failed on the following:\n&#34;
            raise Exception(msg + &#39;\n&#39;.join([f.name for p,f in zip(passed,files) if not p]))

# Cell
def convert_md(fname, dest_path, img_path=&#39;docs/images/&#39;, jekyll=True):
    &#34;Convert a notebook `fname` to a markdown file in `dest_path`.&#34;
    fname = Path(fname).absolute()
    if not img_path: img_path = fname.stem + &#39;_files/&#39;
    Path(img_path).mkdir(exist_ok=True, parents=True)
    nb = read_nb(fname)
    meta_jekyll = get_metadata(nb[&#39;cells&#39;])
    try: meta_jekyll[&#39;nb_path&#39;] = str(fname.relative_to(Config().lib_path.parent))
    except: meta_jekyll[&#39;nb_path&#39;] = str(fname)
    nb[&#39;cells&#39;] = compose(*process_cells)(nb[&#39;cells&#39;])
    nb[&#39;cells&#39;] = [compose(partial(adapt_img_path, fname=fname, dest=dest_path, jekyll=jekyll), *process_cell)(c)
                   for c in nb[&#39;cells&#39;]]
    fname = Path(fname).absolute()
    dest_name = fname.with_suffix(&#39;.md&#39;).name
    exp = nbdev_exporter(cls=MarkdownExporter, template_file=&#39;jekyll-md.tpl&#39; if jekyll else &#39;md.tpl&#39;)
    export = exp.from_notebook_node(nb, resources=meta_jekyll)
    md = export[0]
    for ext in [&#39;png&#39;, &#39;svg&#39;]:
        md = re.sub(r&#39;!\[&#39;+ext+&#39;\]\((.+)\)&#39;, &#39;![&#39;+ext+&#39;](&#39; + img_path + &#39;\\1)&#39;, md)
    with (Path(dest_path)/dest_name).open(&#39;w&#39;) as f: f.write(md)
    for n,o in export[1][&#39;outputs&#39;].items():
            with open(Path(dest_path)/img_path/n, &#39;wb&#39;) as f: f.write(o)

# Cell
_re_att_ref = re.compile(r&#39; *!\[(.*)\]\(attachment:image.png(?: &#34;(.*)&#34;)?\)&#39;)

# Cell
try: from PIL import Image
except: pass # Only required for _update_att_ref

# Cell
_tmpl_img = &#39;&lt;img alt=&#34;{title}&#34; width=&#34;{width}&#34; caption=&#34;{title}&#34; id=&#34;{id}&#34; src=&#34;{name}&#34;&gt;&#39;

def _update_att_ref(line, path, img):
    m = _re_att_ref.match(line)
    if not m: return line
    alt,title = m.groups()
    w = img.size[0]
    if alt==&#39;screenshot&#39;: w //= 2
    if not title: title = &#34;TK: add title&#34;
    return _tmpl_img.format(title=title, width=str(w), id=&#39;TK: add it&#39;, name=str(path))

# Cell
def _nb_detach_cell(cell, dest, use_img):
    att,src = cell[&#39;attachments&#39;],cell[&#39;source&#39;]
    mime,img = first(first(att.values()).items())
    ext = mime.split(&#39;/&#39;)[1]
    for i in range(99999):
        p = dest/(f&#39;att_{i:05d}.{ext}&#39;)
        if not p.exists(): break
    img = b64decode(img)
    p.write_bytes(img)
    del(cell[&#39;attachments&#39;])
    if use_img:  return [_update_att_ref(o,p,Image.open(p)) for o in src]
    else: return [o.replace(&#39;attachment:image.png&#39;, str(p)) for o in src]

# Cell
def nb_detach_cells(path_nb, dest=None, replace=True, use_img=False):
    &#34;Export cell attachments to `dest` and update references&#34;
    path_nb = Path(path_nb)

    dest = Path(dest)
    dest.mkdir(exist_ok=True, parents=True)
    j = json.load(path_nb.open())
    atts = [o for o in j[&#39;cells&#39;] if &#39;attachments&#39; in o]
    for o in atts: o[&#39;source&#39;] = _nb_detach_cell(o, dest, use_img)
    if atts and replace: json.dump(j, path_nb.open(&#39;w&#39;))
    if not replace: return j

# Cell
import time,random,warnings

# Cell
def _leaf(k,v):
    url = &#39;external_url&#39; if &#34;http&#34; in v else &#39;url&#39;
    #if url==&#39;url&#39;: v=v+&#39;.html&#39;
    return {&#39;title&#39;:k, url:v, &#39;output&#39;:&#39;web,pdf&#39;}

# Cell
_k_names = [&#39;folders&#39;, &#39;folderitems&#39;, &#39;subfolders&#39;, &#39;subfolderitems&#39;]
def _side_dict(title, data, level=0):
    k_name = _k_names[level]
    level += 1
    res = [(_side_dict(k, v, level) if isinstance(v,dict) else _leaf(k,v))
        for k,v in data.items()]
    return ({k_name:res} if not title
            else res if title.startswith(&#39;empty&#39;)
            else {&#39;title&#39;: title, &#39;output&#39;:&#39;web&#39;, k_name: res})

# Cell
_re_catch_title = re.compile(&#39;^title\s*:\s*(\S+.*)$&#39;, re.MULTILINE)

# Cell
def _get_title(fname):
    &#34;Grabs the title of html file `fname`&#34;
    with open(fname, &#39;r&#39;) as f: code = f.read()
    src =  _re_catch_title.search(code)
    return fname.stem if src is None else src.groups()[0]

# Cell
def create_default_sidebar():
    &#34;Create the default sidebar for the docs website&#34;
    dic = {&#34;Overview&#34;: &#34;/&#34;}
    files = [f for f in Config().nbs_path.glob(&#39;*.ipynb&#39;) if not f.name.startswith(&#39;_&#39;)]
    fnames = [_nb2htmlfname(f) for f in sorted(files)]
    titles = [_get_title(f) for f in fnames if &#39;index&#39; not in f.stem!=&#39;index&#39;]
    if len(titles) &gt; len(set(titles)): print(f&#34;Warning: Some of your Notebooks use the same title ({titles}).&#34;)
    dic.update({_get_title(f):f&#39;/{f.stem}&#39; for f in fnames if f.stem!=&#39;index&#39;})
    dic = {Config().lib_name: dic}
    json.dump(dic, open(Config().doc_path/&#39;sidebar.json&#39;, &#39;w&#39;), indent=2)

# Cell
def make_sidebar():
    &#34;Making sidebar for the doc website form the content of `doc_folder/sidebar.json`&#34;
    if not (Config().doc_path/&#39;sidebar.json&#39;).exists() or Config().custom_sidebar == &#39;False&#39;: create_default_sidebar()
    sidebar_d = json.load(open(Config().doc_path/&#39;sidebar.json&#39;, &#39;r&#39;))
    res = _side_dict(&#39;Sidebar&#39;, sidebar_d)
    res = {&#39;entries&#39;: [res]}
    res_s = yaml.dump(res, default_flow_style=False)
    res_s = res_s.replace(&#39;- subfolders:&#39;, &#39;  subfolders:&#39;).replace(&#39; - - &#39;, &#39;   - &#39;)
    res_s = f&#34;&#34;&#34;
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# Instead edit {&#39;../../sidebar.json&#39;}
&#34;&#34;&#34;+res_s
    open(Config().doc_path/&#39;_data/sidebars/home_sidebar.yml&#39;, &#39;w&#39;).write(res_s)</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">debug</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&gt; <span class="ansi-green-fg">/Users/glavee/anaconda3/envs/p37/lib/python3.7/site-packages/nbdev/export2html.py</span>(488)<span class="ansi-cyan-fg">notebook2html</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-fg">    486 </span><span class="ansi-red-fg">        </span><span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> all<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">    487 </span><span class="ansi-red-fg">            </span>msg <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">&#34;Conversion failed on the following:\n&#34;</span>
<span class="ansi-green-fg">--&gt; 488 </span><span class="ansi-red-fg">            </span><span class="ansi-green-fg">raise</span> Exception<span class="ansi-blue-fg">(</span>msg <span class="ansi-blue-fg">+</span> <span class="ansi-blue-fg">&#39;\n&#39;</span><span class="ansi-blue-fg">.</span>join<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">[</span>f<span class="ansi-blue-fg">.</span>name <span class="ansi-green-fg">for</span> p<span class="ansi-blue-fg">,</span>f <span class="ansi-green-fg">in</span> zip<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">,</span>files<span class="ansi-blue-fg">)</span> <span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> p<span class="ansi-blue-fg">]</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-fg">    489 </span>
<span class="ansi-green-fg">    490 </span><span class="ansi-red-fg"># Cell</span>

ipdb&gt; passed
[False, False]
ipdb&gt; l
<span class="ansi-green-intense-fg ansi-bold">    483 </span>    <span class="ansi-green-fg">if</span> len<span class="ansi-blue-fg">(</span>files<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">==</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">:</span> print<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">&#34;No notebooks were modified&#34;</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    484 </span>    <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    485 </span>        passed <span class="ansi-blue-fg">=</span> parallel<span class="ansi-blue-fg">(</span>_notebook2html<span class="ansi-blue-fg">,</span> files<span class="ansi-blue-fg">,</span> n_workers<span class="ansi-blue-fg">=</span>n_workers<span class="ansi-blue-fg">,</span> cls<span class="ansi-blue-fg">=</span>cls<span class="ansi-blue-fg">,</span> template_file<span class="ansi-blue-fg">=</span>template_file<span class="ansi-blue-fg">,</span> exporter<span class="ansi-blue-fg">=</span>exporter<span class="ansi-blue-fg">,</span> dest<span class="ansi-blue-fg">=</span>dest<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    486 </span>        <span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> all<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    487 </span>            msg <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">&#34;Conversion failed on the following:\n&#34;</span>
<span class="ansi-green-fg">--&gt; 488 </span><span class="ansi-red-fg">            </span><span class="ansi-green-fg">raise</span> Exception<span class="ansi-blue-fg">(</span>msg <span class="ansi-blue-fg">+</span> <span class="ansi-blue-fg">&#39;\n&#39;</span><span class="ansi-blue-fg">.</span>join<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">[</span>f<span class="ansi-blue-fg">.</span>name <span class="ansi-green-fg">for</span> p<span class="ansi-blue-fg">,</span>f <span class="ansi-green-fg">in</span> zip<span class="ansi-blue-fg">(</span>passed<span class="ansi-blue-fg">,</span>files<span class="ansi-blue-fg">)</span> <span class="ansi-green-fg">if</span> <span class="ansi-green-fg">not</span> p<span class="ansi-blue-fg">]</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    489 </span>
<span class="ansi-green-intense-fg ansi-bold">    490 </span><span class="ansi-red-fg"># Cell</span>
<span class="ansi-green-intense-fg ansi-bold">    491 </span><span class="ansi-green-fg">def</span> convert_md<span class="ansi-blue-fg">(</span>fname<span class="ansi-blue-fg">,</span> dest_path<span class="ansi-blue-fg">,</span> img_path<span class="ansi-blue-fg">=</span><span class="ansi-blue-fg">&#39;docs/images/&#39;</span><span class="ansi-blue-fg">,</span> jekyll<span class="ansi-blue-fg">=</span><span class="ansi-green-fg">True</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    492 </span>    <span class="ansi-blue-fg">&#34;Convert a notebook `fname` to a markdown file in `dest_path`.&#34;</span>
<span class="ansi-green-intense-fg ansi-bold">    493 </span>    fname <span class="ansi-blue-fg">=</span> Path<span class="ansi-blue-fg">(</span>fname<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">.</span>absolute<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span>

ipdb&gt; _notebook2html
&lt;function _notebook2html at 0x10bd06510&gt;
ipdb&gt; c
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">??</span>export2html.notebook2html
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span>

<span class="c1"># Check for YYYY-MM-DD</span>
<span class="n">_re_blog_date</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([12]\d</span><span class="si">{3}</span><span class="s1">-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])-)&#39;</span><span class="p">)</span>
<span class="c1"># Check for leading dashses or numbers</span>
<span class="n">_re_numdash</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(^[-\d]+)&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rename_for_jekyll</span><span class="p">(</span><span class="n">nb_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">warnings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Path&#39;s filename string appended with its modified time in YYYY-MM-DD format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">nb_path</span><span class="o">.</span><span class="n">exists</span><span class="p">(),</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{nb_path}</span><span class="s1"> could not be found.&#39;</span>

    <span class="c1"># Checks if filename is compliant with Jekyll blog posts</span>
    <span class="k">if</span> <span class="n">_re_blog_date</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">nb_path</span><span class="o">.</span><span class="n">name</span><span class="p">):</span> <span class="k">return</span> <span class="n">nb_path</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;.md&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clean_name</span> <span class="o">=</span> <span class="n">_re_numdash</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nb_path</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;.md&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>

        <span class="c1"># Gets the file&#39;s last modified time and and append YYYY-MM-DD- to the beginning of the filename</span>
        <span class="n">mdate</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">nb_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">86400</span> <span class="c1"># subtract one day b/c dates in the future break Jekyll</span>
        <span class="n">dtnm</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">mdate</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">-&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">clean_name</span>
        <span class="k">assert</span> <span class="n">_re_blog_date</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">dtnm</span><span class="p">),</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{dtnm}</span><span class="s1"> is not a valid name, filename must be pre-pended with YYYY-MM-DD-&#39;</span>
        <span class="c1"># push this into a set b/c _nb2htmlfname gets called multiple times per conversion</span>
        <span class="k">if</span> <span class="n">warnings</span><span class="p">:</span> <span class="n">warnings</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nb_path</span><span class="p">,</span> <span class="n">dtnm</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dtnm</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>ls  -l /Users/glavee/repos/test_fp1/_action_files/fastpages.tpl
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-rw-r--r--  1 glavee  110511705  685 Apr 13 15:55 /Users/glavee/repos/test_fp1/_action_files/fastpages.tpl
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">??</span>export2html
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

